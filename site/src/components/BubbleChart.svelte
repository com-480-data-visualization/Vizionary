<script lang="ts">
    import { onMount } from "svelte";
    import * as d3 from "d3";

    // Props with default values
    export let width: number = 800;
    export let height: number = 1000;

    // DOM references
    let element: HTMLDivElement;

    // Event handlers
    export let onBubbleSelect: (data: any) => void = () => {};

    onMount(async function () {
        try {
            // Fetch data from static file
            const data = await d3.json("olympic-data.json"); // These are values for the Olympic games, generated by ChatGPT.


            // Create and render the chart
            const chart = createOlympicBubbleChart(data, {
                width: element.clientWidth || width,
                height: element.clientHeight || height,
                onSelect: onBubbleSelect,
            });

            // Append the chart to the DOM
            d3.select(element).append(() => chart);

            // Handle resizing
            const resizeObserver = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    if (entry.target === element) {
                        // Redraw chart when container size changes
                        element.innerHTML = "";
                        const newChart = createOlympicBubbleChart(data, {
                            width: entry.contentRect.width,
                            height: entry.contentRect.height,
                            onSelect: onBubbleSelect,
                        });
                        d3.select(element).append(() => newChart);
                    }
                }
            });

            resizeObserver.observe(element);

            // Cleanup observer on component destroy
            return () => {
                resizeObserver.disconnect();
            };
        } catch (error) {
            console.error("Error loading Olympic data:", error);
        }
    });

    function createOlympicBubbleChart(
        data: any[],
        options: {
            width: number;
            height: number;
            onSelect: (d: any) => void;
        },
    ) {
        const { width, height, onSelect } = options;
        let yearSelected: number | null = null;

        // Size scale for bubbles based on total athletes
        const sizeScale = d3
            .scaleSqrt()
            .domain([0, d3.max(data, (d) => d.total_athletes) || 0])
            .range([20, 50]);

        // Color scales for summer and winter Olympics
        const summerColorScale = d3
            .scaleLinear<string>()
            .domain([0, 1])
            .range(["rgba(255, 158, 0, 0.3)", "rgba(255, 158, 0, 0.9)"]);

        const winterColorScale = d3
            .scaleLinear<string>()
            .domain([0, 1])
            .range(["rgba(79, 195, 247, 0.3)", "rgba(79, 195, 247, 0.9)"]);

        // Create SVG element
        const svg = d3
            .create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("preserveAspectRatio", "xMidYMid meet");

        // Create a group for all elements
        const bubbleGroup = svg.append("g");

        // Create bubble nodes
        const bubbles = bubbleGroup
            .selectAll(".bubble-group")
            .data(data)
            .join("g")
            .attr("class", "bubble-group");

        // Add bubbles (circles)
        bubbles
            .append("circle")
            .attr("class", "bubble")
            .attr("r", (d) => sizeScale(d.total_athletes))
            .attr("fill", (d) => {
                const colorScale =
                    d.season === "Summer" ? summerColorScale : winterColorScale;
                return colorScale(d.genetic_impact_ratio);
            })
            .attr("stroke", "#fff")
            .attr("stroke-width", 1)
            .attr("cursor", "pointer")
            .on("mouseover", function (event, d) {
                d3.select(this).classed("holographic-effect", true);

                const tooltip = d3
                    .select(element)
                    .append("div")
                    .attr("class", "tooltip")
                    .style("position", "absolute")
                    .style("background", "rgba(0, 0, 0, 0.8)")
                    .style("color", "white")
                    .style("border-radius", "5px")
                    .style("padding", "10px")
                    .style("pointer-events", "none")
                    .style("z-index", "100")
                    .style("opacity", "0");

                tooltip
                    .html(
                        `
            <strong>${d.year} ${d.season} Olympics - ${d.city}</strong><br>
            Athletes: ${d.total_athletes.toLocaleString()}<br>
            Countries: ${d.total_countries}<br>
            Events: ${d.total_events}<br>
            Genetic Impact: ${Math.round(d.genetic_impact_ratio * 100)}%
          `,
                    )
                    .style("left", `${event.pageX}px`)
                    .style("top", `${event.pageY}px`)
                    .transition()
                    .duration(300)
                    .style("opacity", "1");

                d3.select(this.parentNode).raise();
            })
            .on("mousemove", function (event) {
                d3.select(".tooltip")
                    .style("left", `${event.pageX - 520}px`)
                    .style("top", `${event.pageY - 175}px`);
            })
            .on("mouseout", function () {
                d3.select(this).classed("holographic-effect", false);
                d3.select(".tooltip").remove();
            })
            // When a bubble is clicked
            .on("click", function (event, d) {
                event.stopPropagation();

                // Center coordinates of the SVG
                const centerX = 0 // width / 2;
                const centerY = 0 // height / 2;

                // Current position of the bubble
                const currentX = d.x;
                const currentY = d.y;

                // Calculate translation needed to center the bubble
                const translateX = centerX - currentX;
                const translateY = centerY - currentY;

                console.log(d.x, d.y);


                // Reset any previously selected bubbles
                if (yearSelected !== null && yearSelected !== d.year) {
                    bubbleGroup
                        .selectAll(".bubble-group")
                        .filter((b) => b.year !== yearSelected)
                        .classed("selected", false)
                }

                yearSelected = d.year;
                d3.select(this).classed("selected", false);

                // Notify selection handler

            });

        // Add year labels
        bubbles
            .append("text")
            .attr("class", "bubble-label")
            .attr("text-anchor", "middle")
            .attr("dy", ".3em")
            .style("pointer-events", "none")
            .style("fill", "#fff")
            .style("font-weight", "bold")
            .text((d) => d.year);

        // Setup force simulation
        const simulation = d3
            .forceSimulation(data)
            .force("charge", d3.forceManyBody().strength(5))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force(
                "collision",
                d3
                    .forceCollide()
                    .radius((d) => sizeScale(d.total_athletes) + 2),
            )
            .force("x", d3.forceX(width / 2).strength(0.05))
            .force("y", d3.forceY(height / 2).strength(0.05))
            .on("tick", () => {
                bubbles.attr("transform", (d) => `translate(${d.x}, ${d.y})`);
            });

        // Custom force to separate summer and winter Olympics
        simulation.force("season", (alpha) => {
            const summerY = height * 0.4;
            const winterY = height * 0.6;
            const strength = 0.2;

            for (let i = 0; i < data.length; i++) {
                const d = data[i];
                const targetY = d.season === "Summer" ? summerY : winterY;
                d.y += (targetY - d.y) * strength * alpha;
            }
        });

        // Custom force to spread Olympics by year
        simulation.force("year", (alpha) => {
            const yearExtent = d3.extent(data, (d) => d.year) as [
                number,
                number,
            ];
            const yearScale = d3
                .scaleLinear()
                .domain(yearExtent)
                .range([width * 0.1, width * 0.9]);

            const strength = 0.3;

            for (let i = 0; i < data.length; i++) {
                const d = data[i];
                const targetX = yearScale(d.year);
                d.x += (targetX - d.x) * strength * alpha;
            }
        });

        // Add CSS directly to the SVG
        svg.append("style").text(`
        .holographic-effect {
          filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.8));
        }
        
        .selected {
          stroke: #ffcc00;
          stroke-width: 3px;
        }
        
      `);

        return svg.node();
    }
</script>

<div class="bubble-chart-container" bind:this={element}>
    <!-- D3 will insert the SVG here -->
</div>

<style>
    .bubble-chart-container {
        width: 100%;
        height: 100%;
        background-color: #f8f9fa;
        border-radius: 0.75rem;
        overflow: hidden;
        position: relative;
    }
</style>
